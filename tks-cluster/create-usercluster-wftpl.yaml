apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: create-tks-usercluster
  namespace: argo
spec:
  entrypoint: deploy
  arguments:
    parameters:
    - name: contract_id
      value: "P0010010a"
    - name: cluster_id
      value: "C011b88fa"
    - name: site_name
      value: "{{ workflow.parameters.cluster_id }}"
    - name: template_name
      value: "aws-reference"
    - name: git_account
      value: "tks-management"
    - name: manifest_repo_url
      value: ""
    - name: revision
      value: "main"
    - name: app_prefix
      value: "{{workflow.parameters.cluster_id}}"
    - name: tks_info_host
      value: "tks-info.tks.svc"

  volumes:
  - name: kubeconfig-adm
    secret:
      secretName: tks-admin-kubeconfig-secret
  - name: artifacts
    configMap:
      name: aws-artifacts
      defaultMode: 0555
  - name: tks-proto-vol
    configMap:
      name: tks-proto
  - name: awsconfig
    secret:
      secretName: awsconfig-secret
      
  templates:
  - name: deploy
    steps:
    - - name: tks-get-cluster-info
        templateRef:
          name: tks-get-cluster
          template: getTksCluster

    - - name: tks-create-cluster-repo
        templateRef:
          name: tks-create-cluster-repo
          template: main
        arguments:
          parameters:
          - name: cluster_info
            value: "{{steps.tks-get-cluster-info.outputs.parameters.cluster_info}}"

    - - name: k8s-by-aws
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters: 
          - name: list
            value: |
              [
                { 
                  "app_group": "tks-cluster",
                  "path": "cluster-api-aws",
                  "namespace": "argo",
                  "target_cluster": "tks-admin"
                }
              ]
        when: "{{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}} == aws"

    - - name: k8s-by-byoh
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters:
          - name: list
            value: |
              [
                {
                  "app_group": "tks-cluster",
                  "path": "cluster-api-byoh",
                  "namespace": "argo",
                  "target_cluster": "tks-admin"
                }
              ]
        when: "{{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}} == byoh"

    - - name: init-cluster-for-tks
        template: init-cluster-for-tks
        arguments:
          parameters:
            - name: cluster_id
              value: "{{ workflow.parameters.cluster_id }}"
            - name: infra_provider
              value: "{{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}}"

    - - name: create-aws-ebs-csi-iam
        templateRef:
          name: aws-ebs-csi-iam
          template: createIAMRole
        when: >-
            ( {{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}} == aws &&
              {{steps.tks-create-cluster-repo.outputs.parameters.managed_cluster}} == true
            )

    - - name: install-cluster-autoscaler-rbac
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters:
          - name: list
            value: |
              [
                {
                  "app_group": "tks-cluster",
                  "path": "cluster-autoscaler-rbac",
                  "namespace": "argo",
                  "target_cluster": "tks-admin"
                }
              ]

    - - name: prepare-cluster-autoscaler
        template: prepare-cluster-autoscaler

    - - name: install-volumesnapshot-crds
        template: install-volumesnapshot-crds

    - - name: install-addons-common
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters:
          - name: list
            value: |
              [
                { 
                  "app_group": "tks-cluster",
                  "path": "kubernetes-addons",
                  "namespace": "taco-system",
                  "target_cluster": ""
                },
                {
                  "app_group": "tks-cluster",
                  "path": "ingress-nginx",
                  "namespace": "taco-system",
                  "target_cluster": ""
                },
                {
                  "app_group": "tks-cluster",
                  "path": "metrics-server",
                  "namespace": "kube-system",
                  "target_cluster": ""
                },
                {
                  "app_group": "tks-cluster",
                  "path": "cluster-autoscaler",
                  "namespace": "kube-system",
                  "target_cluster": ""
                }
              ]

    - - name: install-addons-aws
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters:
          - name: list
            value: |
              [
                {
                  "app_group": "tks-cluster",
                  "path": "aws-ebs-csi-driver",
                  "namespace": "kube-system",
                  "target_cluster": ""
                }
              ]
        when: >-
            ( {{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}} == aws &&
              {{steps.tks-create-cluster-repo.outputs.parameters.managed_cluster}} == false
            )

    - - name: create-internal-communication
        templateRef:
          name: manage-internal-communication
          template: deploy
        when: "{{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}} == aws"

    - - name: install-addons-byoh
        templateRef:
          name: create-application
          template: installApps
        arguments:
          parameters:
          - name: list
            value: |
              [
                {
                  "app_group": "tks-cluster-byoh",
                  "path": "local-path-provisioner",
                  "namespace": "taco-system",
                  "target_cluster": ""
                }
              ]
        when: "{{steps.tks-create-cluster-repo.outputs.parameters.infra_provider}} == byoh"

  #######################
  # Template Definition #
  #######################
  - name: init-cluster-for-tks
    inputs:
      parameters:
        - name: cluster_id
        - name: infra_provider
    container:
      name: cluster-init
      image: sktcloud/python_kubectl_argo:ft
      command:
        - /bin/bash
        - '-exc'
        - |
          cp /kube/value kubeconfig_adm
          export KUBECONFIG=kubeconfig_adm

          case $INFRA_PROVIDER in
            aws)
              # check whether this workload cluster is managed or not
              kcp_count=$(kubectl get kcp -n $CLUSTER_ID $CLUSTER_ID | grep -v NAME | wc -l)
              awsmcp_count=$(kubectl get awsmcp -n $CLUSTER_ID $CLUSTER_ID | grep -v NAME | wc -l)

              if [ $kcp_count = 1 ]; then
                kubectl wait --for=condition=Available --timeout=3600s kcp -n $CLUSTER_ID $CLUSTER_ID

                KUBECONFIG_WORKLOAD=$(kubectl get secret -n $CLUSTER_ID $CLUSTER_ID-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
              elif [ $awsmcp_count = 1 ]; then
                kubectl wait --for=condition=ready --timeout=3600s awsmcp -n $CLUSTER_ID $CLUSTER_ID

                KUBECONFIG_WORKLOAD=$(kubectl get secret -n $CLUSTER_ID $CLUSTER_ID-user-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
              else
                echo "Wrong AWS Cluster type!"
                exit 1
              fi

              cat <<< "$KUBECONFIG_WORKLOAD" > kubeconfig_workload

              echo "Wait for machinepool $CLUSTER_ID-mp-$TKS_NODE_NAME generated"
              while [ $(kubectl get machinepool -n $CLUSTER_ID $CLUSTER_ID-mp-$TKS_NODE_NAME --ignore-not-found | wc -l) == 0 ]
              do
                echo "Wait for machinepools deployed (1s)"
                sleep 1
              done

              desired_replicas=$(kubectl get machinepool -n $CLUSTER_ID $CLUSTER_ID-mp-$TKS_NODE_NAME -o=jsonpath='{.spec.replicas}' )
              while [ $(kubectl get machinepool -n $CLUSTER_ID $CLUSTER_ID-mp-$TKS_NODE_NAME -o=jsonpath='{.status.nodeRefs}' | jq '.[].uid' | wc -l) != $desired_replicas ]
              do
                echo "Wait for instance is ready (1s)"
                sleep 1
              done

              for node in $(kubectl get machinepool -n $CLUSTER_ID $CLUSTER_ID-mp-$TKS_NODE_NAME -o=jsonpath='{.status.nodeRefs}'| jq -r '.[].name')
              do
                kubectl --kubeconfig=kubeconfig_workload label node $node taco-lma=enabled taco-ingress-gateway=enabled taco-egress-gateway=enabled servicemesh=enabled --overwrite
              done
              ;;

            byoh)
              kubectl wait --for=condition=Available --timeout=600s kcp -n $CLUSTER_ID $CLUSTER_ID

              KUBECONFIG_WORKLOAD=$(kubectl get secret -n $CLUSTER_ID $CLUSTER_ID-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
              cat <<< "$KUBECONFIG_WORKLOAD" > kubeconfig_workload
              ;;

            *)
              echo "Error: wrong infra provider"
              exit 1
              ;;
          esac

          export KUBECONFIG=kubeconfig_workload

          cat <<EOF > taco-system.yaml
          apiVersion: v1
          kind: Namespace
          metadata:
            labels:
              name: taco-system
            name: taco-system
          EOF
          kubectl apply -f taco-system.yaml

          argocd login --insecure --plaintext $ARGO_SERVER --username $ARGO_USERNAME --password $ARGO_PASSWORD
          CLUSTER_CONTEXT=$(kubectl config current-context)

          while [ $(kubectl get no | wc -l) == 0 ]
          do
              echo "Wait for cluster is ready (1s)"
              sleep 1
          done

          if [ $(argocd cluster list | grep \ $CLUSTER_ID\ | wc -l ) == 0 ]; then
              argocd cluster add $CLUSTER_CONTEXT --name $CLUSTER_ID --upsert
          else
              echo "Warning: $1 is already registered on argo-cd server. If unintended, it may occure woring operations."
          fi

      volumeMounts:
      - name: kubeconfig-adm
        mountPath: "/kube"
      envFrom:
      - secretRef:
          name: "decapod-argocd-config"
      env:
      - name: CLUSTER_ID
        value: "{{ inputs.parameters.cluster_id }}"
      - name: INFRA_PROVIDER
        value: "{{ inputs.parameters.infra_provider }}"
      - name: TKS_NODE_NAME
        value: "taco"

  - name: prepare-cluster-autoscaler
    container:
      name: prepare-cluster-autoscaler
      image: portainer/kubectl-shell:latest-v1.21.1-amd64
      command:
        - /bin/bash
        - '-exc'
        - |
          cp /kube/value kubeconfig

          CLUSTER=$(kubectl --kubeconfig kubeconfig get cl -ojsonpath='{.items[0].metadata.name}' -n default)
          ADMIN_USER=${CLUSTER}-admin
          TOKEN=$(kubectl --kubeconfig kubeconfig get secrets -n {{workflow.parameters.cluster_id}} "$(kubectl --kubeconfig kubeconfig get sa cluster-autoscaler -n {{workflow.parameters.cluster_id}} -o=jsonpath={.secrets[0].name})" -o=jsonpath={.data.token} | base64 -d)
          kubectl --kubeconfig kubeconfig config set-credentials cluster-autoscaler --token=$TOKEN
          kubectl --kubeconfig kubeconfig config set-context cluster-autoscaler --cluster=$CLUSTER --user=cluster-autoscaler
          kubectl --kubeconfig kubeconfig config use-context cluster-autoscaler
          kubectl --kubeconfig kubeconfig config delete-context "$ADMIN_USER@$CLUSTER"
          kubectl --kubeconfig kubeconfig config delete-user "$ADMIN_USER"

          KUBECONFIG_WORKLOAD=$(kubectl get secret -n {{workflow.parameters.cluster_id}} {{workflow.parameters.cluster_id}}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
          echo -e "kubeconfig_workload:\n$KUBECONFIG_WORKLOAD" | head -n 5
          cat <<< "$KUBECONFIG_WORKLOAD" > kubeconfig_workload

          kubectl --kubeconfig kubeconfig_workload -n kube-system create secret generic mgmt-kubeconfig --from-file=kubeconfig
      volumeMounts:
      - name: kubeconfig-adm
        mountPath: "/kube"

  - name: install-volumesnapshot-crds
    container:
      name: install-volumesnapshot-crds
      image: portainer/kubectl-shell:latest-v1.21.1-amd64
      command:
        - /bin/bash
        - '-exc'
        - |
          KUBECONFIG=$(kubectl get secret -n {{workflow.parameters.cluster_id}} {{workflow.parameters.cluster_id}}-kubeconfig -o jsonpath="{.data.value}" | base64 -d)
          echo -e "kubeconfig:\n$KUBECONFIG" | head -n 5
          cat <<< "$KUBECONFIG" > kubeconfig_temp

          kubectl --kubeconfig kubeconfig_temp apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/master/client/config/crd/snapshot.storage.k8s.io_volumesnapshotclasses.yaml -n kube-system
          kubectl --kubeconfig kubeconfig_temp apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/master/client/config/crd/snapshot.storage.k8s.io_volumesnapshotcontents.yaml -n kube-system
          kubectl --kubeconfig kubeconfig_temp apply -f https://raw.githubusercontent.com/kubernetes-csi/external-snapshotter/master/client/config/crd/snapshot.storage.k8s.io_volumesnapshots.yaml -n kube-system
